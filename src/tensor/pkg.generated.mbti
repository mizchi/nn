// Generated using `moon info`, DON'T EDIT IT
package "mizchi/wgpu/tensor"

// Values
pub fn add_positional_embedding(Tensor, Tensor) -> Tensor

pub fn attention(Tensor, Tensor, Tensor, Tensor?) -> Result[Tensor, String]

pub fn causal_mask(Int) -> Result[Tensor, String]

pub fn char_tokenizer_from_text(String) -> CharTokenizer

pub fn cross_entropy_backward(Tensor, Array[Int]) -> Tensor

pub fn embedding(Array[Array[Int]], Tensor) -> Tensor

pub fn feed_forward(Tensor, Tensor, Tensor, Tensor, Tensor) -> Result[Tensor, String]

pub fn gelu_backward(Tensor, Tensor) -> Tensor

pub fn generate_greedy(TransformerParams, TransformerConfig, Array[Int], Int) -> Result[Array[Int], String]

pub fn generate_with_temperature(TransformerParams, TransformerConfig, Array[Int], Int, Float, Int) -> Result[Array[Int], String]

pub fn layer_norm_backward(Tensor, Tensor, Array[Float], Array[Float], Tensor, Tensor, Tensor) -> Tensor

pub fn multi_head_attention(Tensor, Tensor, Tensor, Tensor, Tensor, Tensor, Tensor, Int, Tensor?) -> Result[Tensor, String]

pub fn shape_broadcast(Shape, Shape) -> Result[Shape, String]

pub fn shape_from(FixedArray[Int]) -> Result[Shape, String]

pub fn shape_matmul(Shape, Shape) -> Result[Shape, String]

pub fn shape_new(Array[Int]) -> Result[Shape, String]

pub fn shape_new_unchecked(Array[Int]) -> Shape

pub fn shape_transpose(Shape, Int, Int) -> Result[Shape, String]

pub fn tensor_add(Tensor, Tensor) -> Result[Tensor, String]

pub fn tensor_argmax(Tensor) -> Int

pub fn tensor_cross_entropy(Tensor, Array[Int]) -> Result[Float, String]

pub fn tensor_from_array(Array[Float]) -> Tensor

pub fn tensor_full(Shape, Float) -> Tensor

pub fn tensor_gelu(Tensor) -> Tensor

pub fn tensor_layer_norm(Tensor, Tensor, Tensor, Float) -> Result[Tensor, String]

pub fn tensor_log_softmax(Tensor) -> Result[Tensor, String]

pub fn tensor_matmul(Tensor, Tensor) -> Result[Tensor, String]

pub fn tensor_matmul_2d(Tensor, Tensor) -> Result[Tensor, String]

pub fn tensor_mean(Tensor, Int) -> Result[Tensor, String]

pub fn tensor_mul(Tensor, Tensor) -> Result[Tensor, String]

pub fn tensor_new(Shape, Array[Float]) -> Result[Tensor, String]

pub fn tensor_ones(Shape) -> Tensor

pub fn tensor_relu(Tensor) -> Tensor

pub fn tensor_scale(Tensor, Float) -> Tensor

pub fn tensor_softmax(Tensor) -> Result[Tensor, String]

pub fn tensor_sub(Tensor, Tensor) -> Result[Tensor, String]

pub fn tensor_sum(Tensor, Int) -> Result[Tensor, String]

pub fn tensor_zeros(Shape) -> Tensor

pub fn transformer_backward(TransformerCache, TransformerParams, TransformerConfig, TransformerGrads, Array[Int]) -> Float

pub fn transformer_block(Tensor, TransformerBlockParams, TransformerConfig, Tensor?) -> Result[Tensor, String]

pub fn transformer_config(Int, Int, Int, Int, Int, Int) -> Result[TransformerConfig, String]

pub fn transformer_forward(Array[Array[Int]], TransformerParams, TransformerConfig, Tensor?) -> Result[Tensor, String]

pub fn transformer_forward_with_cache(Array[Array[Int]], TransformerParams, TransformerConfig, Tensor?) -> (Tensor, TransformerCache)

pub fn transformer_init_params(TransformerConfig, Int) -> TransformerParams

pub fn transformer_train(String, TransformerConfig, Int, Float, Int) -> Array[Float]

pub fn transformer_zero_grads(TransformerConfig) -> TransformerGrads

// Errors

// Types and methods
pub struct CharTokenizer {
  chars : Array[Char]
}
pub fn CharTokenizer::decode(Self, Array[Int]) -> String
pub fn CharTokenizer::encode(Self, String) -> Array[Int]
pub fn CharTokenizer::vocab_size(Self) -> Int

pub struct Shape {
  dims : Array[Int]
}
pub fn Shape::bytes(Self) -> Int
pub fn Shape::dim(Self, Int) -> Int
pub fn Shape::eq(Self, Self) -> Bool
pub fn Shape::ndim(Self) -> Int
pub fn Shape::numel(Self) -> Int
pub fn Shape::strides(Self) -> Array[Int]
pub fn Shape::to_string(Self) -> String
pub impl Show for Shape

pub struct Tensor {
  data : Array[Float]
  shape : Shape
  offset : Int
  strides : Array[Int]
}
pub fn Tensor::at1(Self, Int) -> Float
pub fn Tensor::at2(Self, Int, Int) -> Float
pub fn Tensor::at3(Self, Int, Int, Int) -> Float
pub fn Tensor::contiguous(Self) -> Self
pub fn Tensor::dim(Self, Int) -> Int
pub fn Tensor::get(Self, Array[Int]) -> Float
pub fn Tensor::is_contiguous(Self) -> Bool
pub fn Tensor::ndim(Self) -> Int
pub fn Tensor::numel(Self) -> Int
pub fn Tensor::reshape(Self, Shape) -> Result[Self, String]
pub fn Tensor::set(Self, Array[Int], Float) -> Unit
pub fn Tensor::set2(Self, Int, Int, Float) -> Unit
pub fn Tensor::slice(Self, Int, Int) -> Result[Self, String]
pub fn Tensor::to_array(Self) -> Array[Float]
pub fn Tensor::to_string(Self) -> String
pub fn Tensor::transpose(Self, Int, Int) -> Result[Self, String]
pub impl Show for Tensor

pub struct TransformerBlockCache {
  x_input : Tensor
  ln1_out : Tensor
  ln1_mean : Array[Float]
  ln1_rstd : Array[Float]
  q_proj : Tensor
  k_proj : Tensor
  v_proj : Tensor
  attn_weights : Array[Array[Float]]
  attn_out_pre_wo : Tensor
  x_after_res1 : Tensor
  ln2_out : Tensor
  ln2_mean : Array[Float]
  ln2_rstd : Array[Float]
  ff_pre_gelu : Tensor
  ff_post_gelu : Tensor
}

pub struct TransformerBlockGrads {
  d_ln1_gamma : Tensor
  d_ln1_beta : Tensor
  d_w_q : Tensor
  d_w_k : Tensor
  d_w_v : Tensor
  d_w_o : Tensor
  d_ln2_gamma : Tensor
  d_ln2_beta : Tensor
  d_ff_w1 : Tensor
  d_ff_b1 : Tensor
  d_ff_w2 : Tensor
  d_ff_b2 : Tensor
}

pub struct TransformerBlockParams {
  ln1_gamma : Tensor
  ln1_beta : Tensor
  w_q : Tensor
  w_k : Tensor
  w_v : Tensor
  w_o : Tensor
  ln2_gamma : Tensor
  ln2_beta : Tensor
  ff_w1 : Tensor
  ff_b1 : Tensor
  ff_w2 : Tensor
  ff_b2 : Tensor
}

pub struct TransformerCache {
  tokens : Array[Array[Int]]
  x_with_pos : Tensor
  block_caches : Array[TransformerBlockCache]
  hidden_before_final_ln : Tensor
  ln_final_mean : Array[Float]
  ln_final_rstd : Array[Float]
  ln_final_out : Tensor
  logits : Tensor
}

pub struct TransformerConfig {
  vocab_size : Int
  d_model : Int
  num_heads : Int
  num_layers : Int
  d_ff : Int
  max_seq_len : Int
  eps : Float
}

pub struct TransformerGrads {
  d_token_embedding : Tensor
  d_pos_embedding : Tensor
  d_blocks : Array[TransformerBlockGrads]
  d_ln_final_gamma : Tensor
  d_ln_final_beta : Tensor
  d_lm_head : Tensor
}

pub struct TransformerParams {
  token_embedding : Tensor
  pos_embedding : Tensor
  blocks : Array[TransformerBlockParams]
  ln_final_gamma : Tensor
  ln_final_beta : Tensor
  lm_head : Tensor
}

// Type aliases

// Traits

